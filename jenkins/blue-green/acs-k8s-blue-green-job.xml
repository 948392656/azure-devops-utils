<?xml version='1.0' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.15">
  <actions />
  <description>{insert-job-description}</description>
  <displayName>{insert-job-display-name}</displayName>
  <keepDependencies>false</keepDependencies>
  <properties>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers/>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.41">
    <script><![CDATA[
node {
    def resourceGroup = '{insert-acs-resource-group}'
    def acs = '{insert-acs-name}'
    def currentEnvironment = 'blue'
    def newEnvironment = { ->
        currentEnvironment == 'blue' ? 'green' : 'blue'
    }
    def expectedTomcatVersion = { ->
        newEnvironment() == 'blue' ? '7' : '8'
    }

    stage('Prepare Sources') {
        // here we generate all the Kubernetes configurations in the pipeline just for demostration,
        // in the real world projects, we will fetch the configurations from SCM most of the time.
        writeFile file: 'k8s/service-blue.yml', text: '''
kind: Service
apiVersion: v1
metadata:
  name: tomcat-service
  labels:
    app: tomcat
    role: blue
    env: prod
spec:
  type: LoadBalancer
  selector:
    app: tomcat
    role: blue
  ports:
    - port: 80
      targetPort: 8080'''
      
        writeFile file: 'k8s/test-endpoint-blue.yml', text: '''
kind: Service
apiVersion: v1
metadata:
  name: tomcat-test-blue
  labels:
    app: tomcat
    role: test-blue
spec:
  type: LoadBalancer
  selector:
    app: tomcat
    role: blue
  ports:
    - port: 80
      targetPort: 8080'''
        
        writeFile file: 'k8s/service-green.yml', text: '''
kind: Service
apiVersion: v1
metadata:
  name: tomcat-service
  labels:
    app: tomcat
    role: green
    env: prod
spec:
  type: LoadBalancer
  selector:
    app: tomcat
    role: green
  ports:
    - port: 80
      targetPort: 8080'''

        writeFile file: 'k8s/test-endpoint-green.yml', text: '''
kind: Service
apiVersion: v1
metadata:
  name: tomcat-test-green
  labels:
    app: tomcat
    role: test-green
spec:
  type: LoadBalancer
  selector:
    app: tomcat
    role: green
  ports:
    - port: 80
      targetPort: 8080'''
        
        writeFile file: 'k8s/deployment-blue.yml', text: '''
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: tomcat-deployment-blue
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: tomcat
        role: blue
    spec:
      containers:
      - name: tomcat-container
        image: tomcat:7.0-jre7
        ports:
        - containerPort: 8080
        readinessProbe:
          httpGet:
            path: /
            port: 8080
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxUnavailable: 1
          maxSurge: 50%'''
        
        writeFile file: 'k8s/deployment-green.yml', text: '''
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: tomcat-deployment-green
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: tomcat
        role: green
    spec:
      containers:
      - name: tomcat-container
        image: tomcat:8.0-jre8
        ports:
        - containerPort: 8080
        readinessProbe:
          httpGet:
            path: /
            port: 8080
      strategy:
        type: RollingUpdate
        rollingUpdate:
          maxUnavailable: 1
          maxSurge: 50%'''
    }

    stage('Ensure Test Endpoints') {
        // Generally, this should be prepared out of the deployment pipeline.
        // And it's less likely to be changed during the deployment.
        // We add it here to keep it simple so that we don't have to configure another job for demonstration.
        acsDeploy azureCredentialsId: 'sp', 
                  configFilePaths: 'k8s/test-endpoint-*.yml',
                  containerService: "$acs | Kubernetes",
                  resourceGroupName: resourceGroup,
                  sshCredentialsId: 'k8s-ssh'
    }

    stage('Check Env') {
        withCredentials([azureServicePrincipal('sp')]) {
            sshagent(['k8s-ssh']) {
                sh """
az login --service-principal -u "\$AZURE_CLIENT_ID" -p "\$AZURE_CLIENT_SECRET" -t "\$AZURE_TENANT_ID"
az account set --subscription "\$AZURE_SUBSCRIPTION_ID"
acs_host=\$(az acs show --resource-group "${resourceGroup}" --name "${acs}" --query "[linuxProfile.adminUsername, masterProfile.fqdn] | join('@', @)" --output tsv)
#az acs kubernetes get-credentials --resource-group "${resourceGroup}" --name "${acs}" --file ./kubeconfig
scp -o StrictHostKeyChecking=no "\$acs_host:.kube/config" kubeconfig
if kubectl --kubeconfig kubeconfig get services --selector='app=tomcat,role=green' --no-headers --output json | jq -r '.items[].metadata.name' | grep -e '^tomcat-service\$'; then
    echo "Current environment: green"
    echo green >current-environment
else
    echo "Current environment: blue"
    echo blue >current-environment
fi
"""
            }
        }
    }

    stage('Deploy') {
        // here we always deploy the same Kubernetes configuration to the same deployment, but this is only for a deployment demonstration.
        // In the real world projects, we would update the image with a new version and upgrade the corresponding deployment.
        currentEnvironment = readFile('current-environment').trim()

        echo "***************************  CURRENT: $currentEnvironment     NEW: ${newEnvironment()}  *****************************"

        currentBuild.displayName = newEnvironment().toUpperCase() + ' Deployment'
        
        acsDeploy azureCredentialsId: 'sp',
                  configFilePaths: "k8s/deployment-${newEnvironment()}.yml",
                  containerService: "$acs | Kubernetes",
                  resourceGroupName: resourceGroup,
                  sshCredentialsId: 'k8s-ssh'
    }

    stage('Verify Staged') {
        sh """
count=0
while true; do
    count=\$(expr \$count + 1)
    test_ip=\$(kubectl --kubeconfig=kubeconfig get services --selector='app=tomcat,role=test-${newEnvironment()}' --output json | jq -r '.items[0].status.loadBalancer.ingress[0].ip')
    if [ "\$test_ip" != null ]; then
        echo 'Test Server IP: \$test_ip'
        break
    fi
    if [ "\$count" -gt 30 ]; then
        echo 'Timeout while waiting for the test server IP'
        exit -1
    fi
    echo "Test server IP not ready, sleep 10 seconds..."
    sleep 10
done
count=0
while true; do
    count=\$(expr \$count + 1)
    if curl "http://\$test_ip" | grep -o "Apache Tomcat/${expectedTomcatVersion()}"; then
        break;
    fi
    if [ "\$count" -gt 30 ]; then
        echo 'Timeout while waiting for the staging environment to be ready'
        exit -1
    fi
    echo "Staging environment not ready, wait 10 seconds..."
    sleep 10
done
"""
    }

    stage('Switch') {
        acsDeploy azureCredentialsId: 'sp',
                  configFilePaths: "k8s/service-${newEnvironment()}.yml",
                  containerService: "$acs | Kubernetes",
                  resourceGroupName: resourceGroup,
                  sshCredentialsId: 'k8s-ssh'
    }

    stage('Verify Prod') {
        sh """
count=0
while true; do
    count=\$(expr \$count + 1)
    prod_ip=\$(kubectl --kubeconfig=kubeconfig get services --selector='app=tomcat,env=prod' --output json | jq -r '.items[0].status.loadBalancer.ingress[0].ip')
    if [ "\$prod_ip" != null ]; then
        echo 'Production Server IP: \$prod_ip'
        break
    fi
    if [ "\$count" -gt 30 ]; then
        echo 'Timeout while waiting for the production server IP'
        exit -1
    fi
    echo "Production server IP not ready, sleep 10 seconds..."
    sleep 10
done
count=0
while true; do
    count=\$(expr \$count + 1)
    if curl "http://\$prod_ip" | grep -o "Apache Tomcat/${expectedTomcatVersion()}"; then
        break;
    fi
    if [ "\$count" -gt 30 ]; then
        echo 'Timeout while waiting for the prod environment to be ready'
        exit -1
    fi
    echo "Prod environment not ready, wait 10 seconds..."
    sleep 10
done
"""
    }
}
]]></script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>
